# 6장 기본적인 리팩터링 (2)

> **Note**
>
> '기본적인 리팩터링' 챕터는 다음 질문을 중심으로 읽어나가시면 좋습니다.
>
> 1. 해당 리팩터링 기법이 왜 필요한가
> 2. 해당 리팩터링 기법을 언제 적용해야 하는가
> 3. 해당 리팩터링 기법은 어떤 효과가 있는가
>
> 프로그래밍의 기본 요소인 변수와 함수를 중심으로 살펴보세요.

## 6.8 매개변수 객체 만들기
p197
> 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다. 나는 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다.
> 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개변수 수가 줄어든다.
> 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사요하기 때문에 일관성도 높여준다.
> 리팩터링의 진정한 힘은 코드를 더 근본적으로 바꿔준다는 데 있다.
> 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만드는 것이다.
> 이 과정에서 새로 만든 데이터 구조가 문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서 코드의 개념적인 그림을 다시 그릴 수도 있다.

p199
> 여기서는 기본 자바스크립트 객체가 아닌 클래스로 선언했는데, 이 리팩터링은 새로 생성한 객체로 동작까지 옮기는 더 큰 작업의 첫 단계로 수행될 때가 많기 때문이다. 이 시나리오에는 클래스가 적합하므로 곧바로 클래스를 사용했다. 한편 값 객체로 만들 가능성이 높기 때문에 세터는 만들지 않는다. 내가 이 리팩터링을 할 때는 대부분 값 객체를 만들게 된다.

p201
> 코드에 범위 개념이 필요함을 깨달았다면 최대값과 최솟값 쌍을 사용하는 코드를 발견할 때마다 범위 객체로 바꾸자

## 6.9 여러 함수를 클래스를 묶기
p202
> 클래스는 데이터와 함수를 하나으 ㅣ공유 환경으로 묶은 후, 다른 프로그램 요소와 어울러질 수 있도록 그중 일부를 외부에 제공한다.
> 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 또한 이런 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.

p203
> 클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 것이다.
> 나는 중첩 함수보다 클래스를 선호하는 편인데, 중첩 함수는 테스트하기가 까다로울 수 있기 때문이다.

p207
> 프로그램의 다른 부분에서 데이터를 갱신할 가능성이 꽤 있을 때는 클래스로 묶어두면 큰 도움이 된다.

## 6.10 여러 함수를 변환 함수로 묶기
p208
> 변환 함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.

p209
> 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는편이 훨씬 낫다. 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다.

p210
> 참고로 나는 본질은 같고 부가 정보만 덧붙이는 변환 함수의 이름은 'enrich'라 하고, 형태가 변할 때만 'transform'이라는 이름을 쓴다.

p211
> 변환 함수 안에서는 결과 객체를 매번 복제할 필요 없이 마음껏 변경해도 된다.

p213
> 측정값에 부가 정보를 추가하는 지금 방식에서 클라이언트가 데이터를 변경하면 심각한 문제가 생길 수 있다. 예컨대 사용량 필드를 변경하면 데이터의 일관성이 깨진다. 내 생각에 자바스크립트에서 이 문제를 방지하기 가장 좋은 방법은 여러 함수를 클래스로 묶기다.

## 6.11 단계 쪼개기
p214
> 나는 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다. 코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다. 모듈이 잘 분리되어 있다면 다른 모듈의 상세 내용은 전혀 기억하지 못해도 원하는 대로 수정을 끝마칠 수도 있다.

p215
> 가장 대표적인 예는 컴파일러다. 컴파일러는 기본적으로 어떤 텍스트(코드)를 입력받아서 실행 가능한 형태(목적 코드)로 변환한다. 컴파일러의 역사가 오래되다 보니 사람들은 컴파일 작업을 여러 단계가 순차적으로 연결된 형태로 분리하면 좋다는 사실을 깨달았다.

p222
> 테스트가 느리거나 불편하면 리팩터링 속도가 느려지고 오류가 생길 가능성도 커진다. 따라서 먼저 테스트를 쉽게 수행할 수 있도록 수정한 다음에 리팩터링하는 게 좋다.

p223
> 이번 예에서는 명령줄 호출과 표준 출력에 쓰는 느리고 불편한 작업과 자주 테스트해야 할 복잡한 동작을 분리함으로써 테스트를 더 쉽게 수행하게 만들었다. 이 원칙을 흔히 험블 객체 패턴이라 한다.

p234
> 핵심은 어디까지나 단계를 명확히 분리하는 데 있기 때문이다.







