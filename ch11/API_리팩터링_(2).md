[⬅️ 10장](https://github.com/read-with-us/refactoring/tree/main/ch10) | [12장 ➡️](https://github.com/read-with-us/refactoring/tree/main/ch12)

# 11장 API 리팩터링 (2)

- [11.8 생성자를 팩터리 함수로 바꾸기](#118-생성자를-팩터리-함수로-바꾸기)
- [11.9 함수를 명령으로 바꾸기](#119-함수를-명령으로-바꾸기)
- [11.10 명령을 함수로 바꾸기](#1110-명령을-함수로-바꾸기)
- [11.11 수정된 값 반환하기](#1111-수정된-값-반환하기)
- [11.12 오류 코드를 예외로 바꾸기](#1112-오류-코드를-예외로-바꾸기)
- [11.13 예외를 사전확인으로 바꾸기](#1113-예외를-사전확인으로-바꾸기)

> **Note**
>
> 'API 리팩터링' 챕터는 다음 질문을 중심으로 읽어나가시면 좋습니다.
>
> 1. 부수효과가 있는 함수와 없는 함수를 어떻게 분리해야 하는가
> 2. 매개변수에 따라 책임 소재가 어디로 이동하는가
> 3. 참조 투명성이란 무엇인가

## 11.8 생성자를 팩터리 함수로 바꾸기

p. 445

> 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙기도 한다. 가령 자바 생성자는 반드시 그 생성자를 정의한 클래스의 인스턴스를 반환해야 한다. 서브클래스의 인스턴스나 프락시를 반환할 수 없다.

> 팩터리 함수에는 이런 제약이 없다.

## 11.9 함수를 명령으로 바꾸기

p. 448

> 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 '명령 객체' 혹은 단순히 '명령<sup>command</sup>'이라 한다.

p. 449

> 명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다. 명령은 되돌리기<sup>undo</sup> 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다.

> 객체를 지원하지만 일급 함수<sup>first-class function</sup>를 지원하지 않는 프로그래밍 언어를 사용할 때는 명령을 이용해 일급 함수의 기능 대부분을 흉내낼 수 있다.

💡 **의견**

- 이수: 일급 함수를 알긴 아는데 대충 아는 것 같아서 다시 한번 찾아봤어요. [MDN](https://developer.mozilla.org/ko/docs/Glossary/First-class_Function#:~:text=%ED%95%A8%EC%88%98%EB%A5%BC%20%EB%8B%A4%EB%A5%B8%20%EB%B3%80%EC%88%98%EC%99%80,%EC%97%90%EB%8F%84%20%ED%95%A0%EB%8B%B9%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.)에 따르면 함수를 다른 변수와 동일하게 다루면 일급 함수라고 합니다. 예를 들어, 함수를 다른 함수에 인수로 제공하거나, 함수가 함수를 반환할 수 있고, 변수에도 할당할 수 있는 경우를 뜻합니다.

  그래서 명령 객체로 일급 함수를 대부분 흉내 낼 수 있다는 뜻은 다른 함수에 인수로 제공하는 대신 같은 객체 내에서 this를 통해 호출하거나 변수에 할당하는 대신 get 호출로 변수인지 계산한 값인지 숨기는 걸 의미하는 게 아닐까 하는 생각이 들었습니다.

- 경진: 함수를 변수에 담아서 들고 다니다가 필요한 시점에 평가해서 사용할 수 있다는 점에서 일급 함수는 정말 매력적이고 편리합니다.
- 시준: 자바에서는 일급 함수나 일급 객체라는 개념이 없는 것으로 아는데 자바스크립트에서는 자유롭게 사용할 수 있어서 좋습니다.

> 명령은 요청을 캡슐화한 객체로, 디자인 패턴 중 명령 패턴<sup>Command Pattern</sup>에서 말하는 명령과 같다.

> 이 원칙에서의 명령은 객체의 겉보기 상태를 변경하는 메서드를 가리킨다. 이 책에서는 이 의미의 명령을 이야기할 때는 명령이란 단어를 쓰지 않으려 노력할 것이다. 대신 '변경 함수<sup>modifier 혹은 mutator</sup>'라 하겠다.

💡 **의견**

- 경진: 명령이라는 용어가 헷갈릴 수 있는데 이 부분을 잘 짚어준 것 같아요. 그리고 커맨드 패턴이 무엇인지 궁금해서 좀 더 조사해보려고 합니다.

> 명령 관련 이름은 사용하는 프로그래밍 언어의 명명규칙을 따른다. 규칙이 딱히 없다면 "execute"나 "call" 같이 명령의 실행 함수에 흔히 쓰이는 이름을 택하자.

p. 451

> 주로 나는 명령이 받는 인수들을 생성자로 옮겨서 execute() 메서드는 매개변수를 받지 않게 하는 편이다.

p. 455

> 사실 자바스크립트에서라면 중첩 함수는 명령의 합리적인 대안이 될 수 있다.

> 명령을 사용하면 (execute 외의) 서브함수들을 테스트와 디버깅에 활용할 수 있기 때문이다.

## 11.10 명령을 함수로 바꾸기

p. 456

> 명령은 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로 쓰인다. 이런 상황이고 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 게 낫다.

## 11.11 수정된 값 반환하기

p. 462

> 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다.

> 데이터가 수정됨을 알려주는 좋은 방법이 있다. 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다. 이 방식으로 코딩하면 호출자 코드를 읽을 때 변수가 갱신될 것임을 분명히 인지하게 된다.

💡 **의견**

- 이수: 이 부분은 문장만 읽었을 때는 명령-질의 분리 원칙이랑 상충하는 거 아닌가 하는 생각이 들었습니다. 이전에 명령 즉 변경 함수는 값을 반환하지 않게 한다는 내용이 있었거든요.

  그런데 예시 코드와 함께 보니까 함수 내부에서 값이 수정되는 것이지 외부에서 호출자가 보았을 때는 질의 함수이기 때문에 어긋나지 않는 얘기였구나 하고 이해가 되었습니다.

> 이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다.

💡 **의견**

- 경진: 실무에서 let을 사용해 변수를 선언하고 함수 내부에서 값을 변경하는 코드를 종종 보게 되는데 리팩터링 후 개선된 코드를 보니 좋았습니다.

  그리고 리팩터링이 완료된 코드에서 for문에 `result +=` 로직이 사용되고 있는데 reduce를 사용할 수 있을 것 같아 함수형으로 구현해보았습니다.

<table>
  <thead>
    <tr>
      <th>명령형</th>
      <th>함수형</th>
    </tr>
  </thead>
  <tbody>
<tr>
<td>

```js
const points = [
  { elevation: 10 },
  { elevation: 40 },
  { elevation: 30 },
  { elevation: 50 },
];
​
function calculateAscent() {
  let result = 0;
  for (let i = 1; i < points.length; i++) {
    const verticalChange = points[i].elevation - points[i - 1].elevation;
    result += (verticalChange > 0) ? verticalChange : 0;
  }
  return result;
}

const totalAscent = calculateAscent();

```

</td>
<td>

```js
const points = [
  { elevation: 10 },
  { elevation: 40 },
  { elevation: 30 },
  { elevation: 50 },
];
​
const calculateAscent = (points) =>
  points.reduceRight((acc, cur, idx) => {
    const verticalChange = cur.elevation - points[idx - 1]?.elevation;
    return verticalChange > 0
      ? acc + verticalChange
      : acc;
  }, 0);

const totalAscent = calculateAscent(points);
```

</td>
</tr>
</tbody>
</table>

<br>

## 11.12 오류 코드를 예외로 바꾸기

p. 465

> 예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘이다. 오류가 발견되면 예외를 던진다. 그러면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다.

> 예외를 사용하면 오류 코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던지는 일을 신경 쓰지 않아도 된다.

> 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다. 달리 말하면 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다.

> 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 여전히 정상 동작할지를 따져보는 것이다. 정상 동작하지 않을 것 같다면 예외를 사용하지 말라는 신호다. 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리해야 한다.

p. 468

잡은 예외는 모두 다시 던져야 한다. 다른 곳에서 발생한 예외를 무심코 삼켜버리고 싶진 않을 테니 말이다.

💡 **의견**

- 경진: catch문에서 예외를 핸들링하지 않고 console.log만 뿌리면 Sentry 같은 모니터링 시스템에서 에러를 잡아내지 못하기 때문에 사용자에게 책임이 전가되는 문제가 있다고 합니다. 그래서 늘 예외 핸들링을 어떻게 하는 것이 좋을지 고민거리입니다. 실무에서는 토스트를 사용해 UI적으로 유저가 인지할 수 있도록 처리하는 편이에요.

- 시준: 저도 항상 코드에서 예외처리 때문에 고민이 많습니다. 예를 들어 사용자 정보나 주문 코드처럼 이전 단계에서 반드시 넘어와야 하고 없어서는 안 되는 데이터가 전달되지 않으면 예외처리를 어떻게 해야 할까 생각합니다. catch문 안에서 if문이 너무 많아지면 가독성이 나빠지지 않을까 이런 고민들이 항상 있어요.

- 시준: Node.js 백엔드에서는 [PM2](https://pm2.keymetrics.io/)를 사용해 모니터링이나 로깅 작업을 하는데 프론트에서는 어떤 서비스를 사용하나요?
- 경진: [클라우드 워치](https://aws.amazon.com/cloudwatch/)를 붙여서 슬랙에 알림이 오게 하고 있어요.
- 이수: 모니터링 정책이 제대로 정립은 안 되었지만 [센트리](https://sentry.io/welcome/)를 도입해서 사용하고 있어요.
- 시준: 백엔드에서는 모니터링에 민감하다 보니 그 밖에도 [그라파나](https://grafana.com/)나 [프로메테우스](https://prometheus.io/) 같은 서비스도 사용한다고 들었습니다.

## 11.13 예외를 사전확인으로 바꾸기

p. 471

> 예외는 '뜻밖의 오류'라는, 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.

p. 472

> 풀에서 자원이 고갈되는 건 에상치 못한 조건이 아니므로 예외 처리로 대응하는 건 옳지 않다. 사용하기 전에 allocated 컬렉션의 상태를 확인하기란 아주 쉬운 일이며, 예상 범주에 있는 동작임을 더 뚜렷하게 드러내주는 방식이다.

💡 **의견**

- 경진: 예외 처리로 대응하지 말아야 하는 경우에 대한 적절한 예시라고 생각합니다. 백엔드에서 이렇게 try/catch 대신 사전에 확인하는 경우가 또 있을까요?
- 시준: 예외 처리할 때 DTO로 validation 체크를 먼저 하고 또 예상할 수 있는 건 try 전에 대응하려고 하는데요. try해서 실행 중에만 잡을 수 있는 경우도 있습니다.

- 시준: 에러 throw에 대해서도 말씀드리면 AOP(Aspect Oriented Programming, 관점 지향 프로그래밍) 방식으로 개발하는데 도메인별로 겹치는 에러 같은 경우 커스텀 에러 코드를 사용합니다. HTTP 상태 코드 외에도 임의의 숫자를 정의해서 사용하고 있어요.
- 경진: HTTP 상태 코드에 임의의 영어 코드를 함께 사용합니다.
- 이수: 같은 방식으로 커스텀 에러 코드를 정의해서 사용하는데요. 듣고 보니 회사마다 방식은 약간 차이가 있어도 에러를 세분화해서 구분할 필요가 있는 건 다 같은 것 같아요.

<br>

[⬅️ 10장](https://github.com/read-with-us/refactoring/tree/main/ch10) | [⬆️ 위로](#11장-API-리팩터링-2) | [12장 ➡️](https://github.com/read-with-us/refactoring/tree/main/ch12)
