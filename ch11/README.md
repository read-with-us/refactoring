[⬅️ 10장](https://github.com/read-with-us/refactoring/tree/main/ch10) | [12장 ➡️](https://github.com/read-with-us/refactoring/tree/main/ch12)

# 11장 API 리팩터링

- [11.1 질의 함수와 변경 함수 분리하기](#111-질의-함수와-변경-함수-분리하기)
- [11.2 함수 매개변수화하기](#112-함수-매개변수화하기)
- [11.3 플래그 인수 제거하기](#113-플래그-인수-제거하기)
- [11.4 객체 통째로 넘기기](#114-객체-통째로-넘기기)
- [11.5 매개변수를 질의 함수로 바꾸기](#115-매개변수를-질의-함수로-바꾸기)
- [11.6 질의 함수를 매개변수로 바꾸기](#116-질의-함수를-매개변수로-바꾸기)
- [11.7 세터 제거하기](#117-세터-제거하기)
- [11.8 생성자를 팩터리 함수로 바꾸기](#118-생성자를-팩터리-함수로-바꾸기)
- [11.9 함수를 명령으로 바꾸기](#119-함수를-명령으로-바꾸기)
- [11.10 명령을 함수로 바꾸기](#1110-명령을-함수로-바꾸기)
- [11.11 수정된 값 반환하기](#1111-수정된-값-반환하기)
- [11.12 오류 코드를 예외로 바꾸기](#1112-오류-코드를-예외로-바꾸기)
- [11.13 예외를 사전확인으로 바꾸기](#1113-예외를-사전확인으로-바꾸기)

<br>

> **Note**
>
> 'API 리팩터링' 챕터는 다음 질문을 중심으로 읽어나가시면 좋습니다.
>
> 1. 부수효과가 있는 함수와 없는 함수를 어떻게 분리해야 하는가
> 2. 매개변수에 따라 책임 소재가 어디로 이동하는가
> 3. 참조 투명성이란 무엇인가

<br>

p.411

> 모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이 블록들을 끼워 맞추는 연결부다.

> 좋은 API는 데이터를 갱신하는 함수와 그저 조회만 하는 함수를 명확하게 구분한다.

<br>

## 11.1 질의 함수와 변경 함수 분리하기

p.413

> 우리는 외부에서 관찰할 수 있는 겉보기 부수효과<sup>observable side effect</sup>가 전혀 없이 값을 반환해주는 함수를 추구해야 한다. 이런 함수는 어느 때건 원하는 만큼 호출해도 아무 문제가 없다. 호출하는 문장의 위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다.

> 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다.

<br>

p.414

> 나는 값을 반환하면서도 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하려 시도한다. 무조건이다!

<br>

## 11.2 함수 매개변수화하기

p.417

> 두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다.

<br>

> 💡 **의견**
>
> - 경진: 리팩터링 후의 코드가 가독성이 훨씬 좋아서 인상 깊었다.
> - 이수: 중간 단계인 `middleBand`부터 리팩터링을 시작한 점이 인상 깊었다.

<table>
  <thead>
    <tr>
      <th>리팩터링 전</th>
      <th>리팩터링 후</th>
    </tr>
  </thead>
  <tbody>
<tr>
<td>

```js
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = bottomBand(usage) * 0.03
                + middleBand(usage) * 0.03
                + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function middleBand(usage) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```

</td>
<td>

```js
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount = withinBand(usage, 0, 100) * 0.03
                + withinBand(usage, 100, 200) * 0.03
                + withinBand(usage, 200, Infinity) * 0.07;
  return usd(amount);
}

function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, 200) - bottom : 0;
}
```

</td>
</tr>
</tbody>
</table>

<br>

## 11.3 플래그 인수 제거하기

p.421

> 플래그 인수<sup>flag argument</sup>란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다.

<br>

p.422

> 내가 플래그 인수를 싫어하는 이유가 있다. 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기가 어려워지기 때문이다. 나는 API를 익힐 때 주로 함수 목록부터 살펴보는데, 플래그 인수가 있으면 함수들의 기능 차이가 잘 드러나지 않는다.

> 불리언 플래그는 코드를 읽는 이에게 뜻을 온전히 전달하지 못하기 때문에 더욱 좋지 못하다.

> 이보다는 다음처럼 특정한 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔하다.

> 플래그 인수가 되려면 호출하는 쪽에서 불리언 값으로 (프로그램에서 사용되는 데이터가 아닌) 리터럴 값을 건네야 한다. 또한, 호출되는 함수는 그 인수를 (다른 함수에 전달하는 데이터가 아닌) 제어 흐름을 결정하는데 사용해야 한다.

<br>

p.426

> 이 코드에서 `isRush`를 최상위 분배 조건문으로 뽑아내려면 생각보다 일이 커질 수도 있어 보인다. 그렇다면 `deliveryDate()`를 감싸는 래핑 함수를 생각해볼 수 있다.

```js
function rushDeliveryDate(anOrder) {
  return deliveryDate(anOrder, true);
}
function regularDeliveryDate(anOrder) {
  return deliveryDate(anOrder, false);
}
```

<br>

> 💡 **의견**
>
> - 경진: 함수 호출부에서 boolean이 있으면 가독성이 떨어진다고 생각해서 가능하면 사용을 피하려고 한다.
> - 플래그 변수 사용이 불가피한 경우에 대한 논의
>   - 경진: `isRush`처럼 의미있는 이름의 변수로 넘기거나, [Named Parameter](https://en.wikipedia.org/wiki/Named_parameter#With_data_structures)를 사용하려고 하는 편이다.
>   - 원진: React에서 추상화 레벨을 일치시키려고 hook으로 가려야는 경우에 사용했다. 또한 최신 IDE에서는 파라미터를 쉽게 확인할 수 있고 타입스크립트를 사용하거나 자바스크립트에서도 JSDoc을 사용하면 파라미터에 대한 설명을 표시할 수 있다.
>   - 이수: react-router-dom에서 제공하는 `useBlocker` hook도 플래그 변수를 사용한다. `useBlocker(blocker, when = true) { ... }` 와 같은 형식이다. ([코드](https://gist.github.com/rmorse/426ffcc579922a82749934826fa9f743#file-react-router-dom-v-6-02-prompt-blocker-js-L16-L39))

<br>

## 11.4 객체 통째로 넘기기

p.427

> 하나의 레코드에서 값 두어 개를 가져와 인수로 넘기는 코드를 보면, 나는 그 값들 대신 레코드를 통째로 넘기고 함수 본문에서 필요한 값들을 꺼내 쓰도록 수정하곤 한다.

> 레코드를 통째로 넘기면 변화에 대응하기 쉽다. 예컨대 그 함수가 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다. 그리고 매개변수 목록이 짧아져서 일반적으로는 함수 사용법을 이해하기 쉬워진다.

> 하지만 함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩터링을 수행하지 않는데, 레코드와 함수가 서로 다른 모듈에 속한 상황이면 특히 더 그렇다.

<br>

p.428

> 많은 사람이 놓치는 사례가 하나 더 있다. 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우다. 이런 상황이면 데이터 여러 개 대신 객체 자신의 참조만 건네도록 수정할 수 있다(자바스크립트라면 `this`를 건넬 것이다).

<br>

## 11.5 매개변수를 질의 함수로 바꾸기

p.433

> 매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다. 즉, 함수의 동작에 변화를 줄 수 있는 일차적인 수단이다.

> 피호출 함수가 스스로 '쉽게' 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다.

> 해당 매개변수를 제거하면 값을 결정하는 책임 주체가 달라진다. 매개변수가 있다면 결정 주체가 호출자가 되고, 없다면 피호출 함수가 된다. 나는 습관적으로 호출하는 쪽을 간소하게 만든다.

<br>

p.434

> 매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다. 가장 흔한 예는 매개변수를 제거하면 피호출 함수에 원치 않은 의존성이 생길 때다.

> 주의사항이 있다. 대상 함수가 참조 투명<sup>referential transparency</sup>해야 한다는 것이다. 참조 투명이란 '함수에 똑같은 값을 건네 호출하면 똑같이 동작한다'는 것이다.

<br>

> 💡 **의견**
>
> - 경진: 리팩터링 전의 패턴을 실무 코드에서 많이 봤던 것 같은데, 리팩터링 후를 잘 익혀서 실무에 적용해보고 싶다.
> - 이수: 함수형 프로그래밍에서는 모든 함수가 참조 투명할까?
> - 경진: 가능한 순수 함수로 개발하는 것을 권장하고 함수를 조합하려면 순수 함수여야만 의미가 있다.
>   참조 투명한 함수 = 순수 함수 = 부수 효과가 없는 함수

<table>
  <thead>
    <tr>
      <th>리팩터링 전</th>
      <th>리팩터링 후</th>
    </tr>
  </thead>
  <tbody>
<tr>
<td>

```js
class Order {
  // ...

  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice;
    let discountLevel;
    if (this.quantity > 100) discountLevel = 2;
    else discountLevel = 1;
    return this.discountedPrice(basePrice, discountLevel);
  }

  discountedPrice(basePrice, discountLevel) {
    switch (discountLevel) {
      case 1: return basePrice * 0.95;
      case 2: return basePrice * 0.9;
    }
  }
}
```

</td>
<td>

```js
class Order {
  // ...

  get finalPrice() {
    const basePrice = this.qunatity * this.itemPrice;
    return this.discountedPrice(basePrice);
  }

  discountedPrice(basePrice) {
    switch (this.discountLevel) {
      case 1: return basePrice * 0.95;
      case 2: return basePrice * 0.9;
    }
  }
}
```

</td>
</tr>
</tbody>
</table>

<br>

## 11.6 질의 함수를 매개변수로 바꾸기

p.437

> 코드를 읽다 보면 함수 안에 두기엔 거북한 참조를 발견할 때가 있다. 전역 변수를 참조한다거나(같은 모듈 안에서라도) 제거하길 원하는 원소를 참조하는 경우가 여기 속한다. 이 문제는 해당 참조를 매개변수로 바꿔 해결할 수 있다. 참조를 풀어내는 책임을 호출자로 옮기는 것이다.

> 이런 상황 대부분은 코드의 의존 관계를 바꾸려 할 때 벌어진다. 예컨대 대상 함수가 더 이상 (매개변수화하려는) 특정 원소에 의존하길 원치 않을 때 일어난다. 이때 두 극단 사이에서 적절한 균형을 찾아야 한다.

## 11.7 세터 제거하기

p.442

> 세터 메서드가 있다고 함은 필드가 수정될 수 있다는 뜻이다. 객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않았을 것이다.

> 첫째, 사람들이 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때다.<br>
> 나라면 세터를 제거해서 객체가 생성된 후에는 값이 바뀌면 안 된다는 뜻을 분명히 할 것이다.

> 두 번째 상황은 클라이언트에서 생성 스크립트<sup>creation script</sup>를 사용해 객체를 생성할 때다.

## 11.8 생성자를 팩터리 함수로 바꾸기

p. 445

> 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙기도 한다. 가령 자바 생성자는 반드시 그 생성자를 정의한 클래스의 인스턴스를 반환해야 한다. 서브클래스의 인스턴스나 프락시를 반환할 수 없다.

> 팩터리 함수에는 이런 제약이 없다.

## 11.9 함수를 명령으로 바꾸기

p. 448

> 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 '명령 객체' 혹은 단순히 '명령<sup>command</sup>'이라 한다.

p. 449

> 명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다. 명령은 되돌리기<sup>undo</sup> 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다.

> 객체를 지원하지만 일급 함수<sup>first-class function</sup>를 지원하지 않는 프로그래밍 언어를 사용할 때는 명령을 이용해 일급 함수의 기능 대부분을 흉내낼 수 있다.

💡 **의견**

- 이수: 일급 함수를 알긴 아는데 대충 아는 것 같아서 다시 한번 찾아봤어요. [MDN](https://developer.mozilla.org/ko/docs/Glossary/First-class_Function#:~:text=%ED%95%A8%EC%88%98%EB%A5%BC%20%EB%8B%A4%EB%A5%B8%20%EB%B3%80%EC%88%98%EC%99%80,%EC%97%90%EB%8F%84%20%ED%95%A0%EB%8B%B9%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.)에 따르면 함수를 다른 변수와 동일하게 다루면 일급 함수라고 합니다. 예를 들어, 함수를 다른 함수에 인수로 제공하거나, 함수가 함수를 반환할 수 있고, 변수에도 할당할 수 있는 경우를 뜻합니다.

  그래서 명령 객체로 일급 함수를 대부분 흉내 낼 수 있다는 뜻은 다른 함수에 인수로 제공하는 대신 같은 객체 내에서 this를 통해 호출하거나 변수에 할당하는 대신 get 호출로 변수인지 계산한 값인지 숨기는 걸 의미하는 게 아닐까 하는 생각이 들었습니다.

- 경진: 함수를 변수에 담아서 들고 다니다가 필요한 시점에 평가해서 사용할 수 있다는 점에서 일급 함수는 정말 매력적이고 편리합니다.
- 시준: 자바에서는 일급 함수나 일급 객체라는 개념이 없는 것으로 아는데 자바스크립트에서는 자유롭게 사용할 수 있어서 좋습니다.

> 명령은 요청을 캡슐화한 객체로, 디자인 패턴 중 명령 패턴<sup>Command Pattern</sup>에서 말하는 명령과 같다.

> 이 원칙에서의 명령은 객체의 겉보기 상태를 변경하는 메서드를 가리킨다. 이 책에서는 이 의미의 명령을 이야기할 때는 명령이란 단어를 쓰지 않으려 노력할 것이다. 대신 '변경 함수<sup>modifier 혹은 mutator</sup>'라 하겠다.

💡 **의견**

- 경진: 명령이라는 용어가 헷갈릴 수 있는데 이 부분을 잘 짚어준 것 같아요. 그리고 커맨드 패턴이 무엇인지 궁금해서 좀 더 조사해보려고 합니다.

> 명령 관련 이름은 사용하는 프로그래밍 언어의 명명규칙을 따른다. 규칙이 딱히 없다면 "execute"나 "call" 같이 명령의 실행 함수에 흔히 쓰이는 이름을 택하자.

p. 451

> 주로 나는 명령이 받는 인수들을 생성자로 옮겨서 execute() 메서드는 매개변수를 받지 않게 하는 편이다.

p. 455

> 사실 자바스크립트에서라면 중첩 함수는 명령의 합리적인 대안이 될 수 있다.

> 명령을 사용하면 (execute 외의) 서브함수들을 테스트와 디버깅에 활용할 수 있기 때문이다.

## 11.10 명령을 함수로 바꾸기

p. 456

> 명령은 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로 쓰인다. 이런 상황이고 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 게 낫다.

## 11.11 수정된 값 반환하기

p. 462

> 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다.

> 데이터가 수정됨을 알려주는 좋은 방법이 있다. 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다. 이 방식으로 코딩하면 호출자 코드를 읽을 때 변수가 갱신될 것임을 분명히 인지하게 된다.

💡 **의견**

- 이수: 이 부분은 문장만 읽었을 때는 명령-질의 분리 원칙이랑 상충하는 거 아닌가 하는 생각이 들었습니다. 이전에 명령 즉 변경 함수는 값을 반환하지 않게 한다는 내용이 있었거든요.

  그런데 예시 코드와 함께 보니까 함수 내부에서 값이 수정되는 것이지 외부에서 호출자가 보았을 때는 질의 함수이기 때문에 어긋나지 않는 얘기였구나 하고 이해가 되었습니다.

> 이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다.

💡 **의견**

- 경진: 실무에서 let을 사용해 변수를 선언하고 함수 내부에서 값을 변경하는 코드를 종종 보게 되는데 리팩터링 후 개선된 코드를 보니 좋았습니다.

  그리고 리팩터링이 완료된 코드에서 for문에 `result +=` 로직이 사용되고 있는데 reduce를 사용할 수 있을 것 같아 함수형으로 구현해보았습니다.

<table>
  <thead>
    <tr>
      <th>명령형</th>
      <th>함수형</th>
    </tr>
  </thead>
  <tbody>
<tr>
<td>

```js
const points = [
  { elevation: 10 },
  { elevation: 40 },
  { elevation: 30 },
  { elevation: 50 },
];
​
function calculateAscent() {
  let result = 0;
  for (let i = 1; i < points.length; i++) {
    const verticalChange = points[i].elevation - points[i - 1].elevation;
    result += (verticalChange > 0) ? verticalChange : 0;
  }
  return result;
}

const totalAscent = calculateAscent();

```

</td>
<td>

```js
const points = [
  { elevation: 10 },
  { elevation: 40 },
  { elevation: 30 },
  { elevation: 50 },
];
​
const calculateAscent = (points) =>
  points.reduceRight((acc, cur, idx) => {
    const verticalChange = cur.elevation - points[idx - 1]?.elevation;
    return verticalChange > 0
      ? acc + verticalChange
      : acc;
  }, 0);

const totalAscent = calculateAscent(points);
```

</td>
</tr>
</tbody>
</table>

<br>

## 11.12 오류 코드를 예외로 바꾸기

p. 465

> 예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘이다. 오류가 발견되면 예외를 던진다. 그러면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다.

> 예외를 사용하면 오류 코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던지는 일을 신경 쓰지 않아도 된다.

> 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다. 달리 말하면 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다.

> 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 여전히 정상 동작할지를 따져보는 것이다. 정상 동작하지 않을 것 같다면 예외를 사용하지 말라는 신호다. 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리해야 한다.

p. 468

잡은 예외는 모두 다시 던져야 한다. 다른 곳에서 발생한 예외를 무심코 삼켜버리고 싶진 않을 테니 말이다.

💡 **의견**

- 경진: catch문에서 예외를 핸들링하지 않고 console.log만 뿌리면 Sentry 같은 모니터링 시스템에서 에러를 잡아내지 못하기 때문에 사용자에게 책임이 전가되는 문제가 있다고 합니다. 그래서 늘 예외 핸들링을 어떻게 하는 것이 좋을지 고민거리입니다. 실무에서는 토스트를 사용해 UI적으로 유저가 인지할 수 있도록 처리하는 편이에요.

- 시준: 저도 항상 코드에서 예외처리 때문에 고민이 많습니다. 예를 들어 사용자 정보나 주문 코드처럼 이전 단계에서 반드시 넘어와야 하고 없어서는 안 되는 데이터가 전달되지 않으면 예외처리를 어떻게 해야 할까 생각합니다. catch문 안에서 if문이 너무 많아지면 가독성이 나빠지지 않을까 이런 고민들이 항상 있어요.

- 시준: Node.js 백엔드에서는 [PM2](https://pm2.keymetrics.io/)를 사용해 모니터링이나 로깅 작업을 하는데 프론트에서는 어떤 서비스를 사용하나요?
- 경진: [클라우드 워치](https://aws.amazon.com/cloudwatch/)를 붙여서 슬랙에 알림이 오게 하고 있어요.
- 이수: 모니터링 정책이 제대로 정립은 안 되었지만 [센트리](https://sentry.io/welcome/)를 도입해서 사용하고 있어요.
- 시준: 백엔드에서는 모니터링에 민감하다 보니 그 밖에도 [그라파나](https://grafana.com/)나 [프로메테우스](https://prometheus.io/) 같은 서비스도 사용한다고 들었습니다.

## 11.13 예외를 사전확인으로 바꾸기

p. 471

> 예외는 '뜻밖의 오류'라는, 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.

p. 472

> 풀에서 자원이 고갈되는 건 에상치 못한 조건이 아니므로 예외 처리로 대응하는 건 옳지 않다. 사용하기 전에 allocated 컬렉션의 상태를 확인하기란 아주 쉬운 일이며, 예상 범주에 있는 동작임을 더 뚜렷하게 드러내주는 방식이다.

💡 **의견**

- 경진: 예외 처리로 대응하지 말아야 하는 경우에 대한 적절한 예시라고 생각합니다. 백엔드에서 이렇게 try/catch 대신 사전에 확인하는 경우가 또 있을까요?
- 시준: 예외 처리할 때 DTO로 validation 체크를 먼저 하고 또 예상할 수 있는 건 try 전에 대응하려고 하는데요. try해서 실행 중에만 잡을 수 있는 경우도 있습니다.

- 시준: 에러 throw에 대해서도 말씀드리면 AOP(Aspect Oriented Programming, 관점 지향 프로그래밍) 방식으로 개발하는데 도메인별로 겹치는 에러 같은 경우 커스텀 에러 코드를 사용합니다. HTTP 상태 코드 외에도 임의의 숫자를 정의해서 사용하고 있어요.
- 경진: HTTP 상태 코드에 임의의 영어 코드를 함께 사용합니다.
- 이수: 같은 방식으로 커스텀 에러 코드를 정의해서 사용하는데요. 듣고 보니 회사마다 방식은 약간 차이가 있어도 에러를 세분화해서 구분할 필요가 있는 건 다 같은 것 같아요.

<br>

[⬅️ 10장](https://github.com/read-with-us/refactoring/tree/main/ch10) | [⬆️ 위로](#11장-API-리팩터링) | [12장 ➡️](https://github.com/read-with-us/refactoring/tree/main/ch12)
