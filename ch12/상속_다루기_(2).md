[⬅️ 11장](https://github.com/read-with-us/refactoring/tree/main/ch11) | [1장 ➡️](https://github.com/read-with-us/refactoring/tree/main/ch01)

# 12장 상속 다루기 (2)

- [12.8 슈퍼클래스 추출하기](#128-슈퍼클래스-추출하기)
- [12.9 계층 합치기](#129-계층-합치기)
- [12.10 서브클래스를 위임으로 바꾸기](#1210-서브클래스를-위임으로-바꾸기)
- [12.11 슈퍼클래스를 위임으로 바꾸기](#1211-슈퍼클래스를-위임으로-바꾸기)

<br>

> **Note**
>
> '상속 다루기' 챕터는 다음 질문을 중심으로 읽어나가시면 좋습니다.
>
> 1. 언제 상속해야 하는가
> 2. 슈퍼클래스와 서브클래스의 요소를 어떻게 정리해야 하는가
> 3. 상속을 오용했다면 어떤 대안이 있는가

<br>

## 12.8 슈퍼클래스 추출하기
p.502
> 슈퍼클래스 추출하기의 대안으로는 클래스 추출하기가 있다. 어느 것을 선택하느냐는 중복 동작을 상속으로 해결하느냐 위임으로 해결하느냐에 달렸다.

<br>

## 12.9 계층 합치기
p.507
> 계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다. 바로 그 둘을 하나로 합쳐야 할 시점이다.

> 미래를 생각하여 더 적합한 이름의 클래스를 남기자. 둘 다 적절치 않다면 임의로 하나를 고른다.

<br>

## 12.10 서브클래스를 위임으로 바꾸기
💡 **의견**
- 상속은 **is-a 관계**일 경우 사용하고, 합성(위임)은 **has-a 관계**일 때 사용합니다.

<br>

p.508
> 하지만 상속에는 단점이 있다. 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다.

> 예컨대 사람 객체의 동작을 '나이대'와 '소득 수준'에 따라 달리 하고 싶다면 서브클래스는 젊은이와 어르신이 되거나, 혹은 부자와 서민이 되어야 한다. 둘 다는 안 된다.

💡 **의견**
- Java, JavaScript는 다중 상속을 지원하지 않으며, C++은 다중 상속을 지원한다.
- 다중상속은 상속 받은 필드나 메서드명이 동일할 경우 문제가 발생할 수 있다.
- 자바스크립트는 다중상속을 지원하지 않는다. ([관련 포스팅](https://velog.io/@hustle-dev/JavaScript-%EB%8B%A4%EC%A4%91%EC%83%81%EC%86%8D))

<br>

p.509
> 또 다른 문제로, 상속은 클래스들의 관계를 아주 긴밀하게 결합한다.

> (클래스) 상속보다는 (객체) 컴포지션을 사용하라!

<br>

p.512
> 상속은 한 번만 사용할 수 있는 도구다.
> 따라서 상속을 사용해야 할 다른 이유가 생긴다면, 그리고 그 이유가 프리미엄 예약 서브클래스보다 가치가 크다고 생각된다면 프리미엄 예약을 (상속이 아닌) 다른 방식으로 표현해야 할 것이다.
> 또한, 기본 예약에서 프리미엄 예약으로 동적으로 전환할 수 있도록 해야 할 수도 있다.

<br>

p.517
> 자바스크립트에서는 객체에 존재하지 않는 속성에 접근하려 하면 `undefined`를 반환하므로 앞의 코드도 그렇게 처리했다.
```js
class Booking {
  // ...
  get hasDinner() {
    return (this._premiumDelegate) 
      ? this._premiumDelegate.hasDinner
      : undefined; 
  }
}
```


💡 **의견**
- 경진: 위의 코드에서는 `undefined`를 반환해주었는데 저였다면 빈 값을 명시적으로 나타내는 `null`을 사용했을 것 같습니다. 다른 분들은 `undefined`와 `null`의 사용을 구분하는 기준이 있나요?
- 이수: 위의 코드에서는 Booking에 `hasDinner`에 대한 어떤 정보도 없으므로 `undefined`를 반환한 것 같습니다.
- 혜수: Optional Chaining을 사용해서 `this._premiumDelegate?.hasDinner`로 축약할 수도 있을 것 같습니다.

<br>

  💡 **의견**
- 이수: React도 합성 모델을 지원합니다. ([링크](https://ko.reactjs.org/docs/composition-vs-inheritance.html))
- 경진: Vue의 slots과 비슷한 것 같습니다.

<br>

## 12.11 슈퍼클래스를 위임으로 바꾸기
p.529
> 상속을 잘못 적용한 예로는 자바의 스택 클래스가 유명하다.

> 리스트의 연산 중 스택에는 적용되지 않는 게 많음에도 그 모든 연산이 스택 인터페이스 그래도 노출되는 게 아닌가! 이보다는 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 더 멋졌을 것이다.

> 제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다.

<br>

p.530
> 이름과 엔진 크기 등을 속성으로 갖는 자동차 모델 클래스(타입)가 있다고 하자.
> 그러면 여기에 차량 식별 번호와 제조일자 메서드를 더하면 물리적인 자동차(인스턴스)를 표현하는 데 재활용할 수 있을 거라 착각할 수 있다.
> 이는 흔하고 미묘한 모델링 실수로, 내가 [타입-인스턴스 동형이의어<sup>type-instance homonym</sup>](https://martinfowler.com/bliki/TypeInstanceHomonym.html)라고 부르는 것이다.

💡 **의견**
- 경진: 논리적인 모델 클래스와 물리적인 인스턴스를 혼용하지 말라는 의미로 이해했는데, 혼자 구현했더라면 재활용했을 것 같아서 사실 무슨 말인지 잘 모르겠습니다.

> 슈퍼 서브/클래스는 강하게 결합된 관계라서 슈퍼클래스를 수정하면 서브클래스가 망가지기 쉽기 때문이다.
 
> 위임의 기능을 이용할 호스트의 함수 모두를 전달 함수<sup>forwarding function</sup>으로 만들어야 한다는 점이다.

💡 **의견**
- 경진: [전달 함수](https://stackoverflow.com/a/3120033)는 함수에 인자를 전달하면서 함수를 호출하는 로직을 가진 함수를 말하는 것 같습니다.
- 혜수: p.522와 같이 '위임을 위해 호출만 하는 함수'를 말하는 것 같습니다.
```js
class Bird {
  // ...
  selectSpeciesDelegate(data) {
    switch(data.type) {
      case '유럽 제비':
        return new EuropeanSwallowDelegate();
      case '아프리카 제비':
        return new AfricanSwallowDelegate(data);
      case '노르웨이 파랑 앵무':
        return new NorwegianBlueParrotDelegate(data);
      default: return null;
    }
  }
}
```

<br>

[⬅️ 11장](https://github.com/read-with-us/refactoring/tree/main/ch11) | [⬆️ 위로](#12장-상속-다루기-2) | [1장 ➡️](https://github.com/read-with-us/refactoring/tree/main/ch01)
